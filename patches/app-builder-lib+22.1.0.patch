diff --git a/node_modules/app-builder-lib/out/electron/electronVersion.js b/node_modules/app-builder-lib/out/electron/electronVersion.js
index 68ad6a2..72b7ee6 100755
--- a/node_modules/app-builder-lib/out/electron/electronVersion.js
+++ b/node_modules/app-builder-lib/out/electron/electronVersion.js
@@ -1,173 +1,253 @@
-"use strict";
+'use strict'
 
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.getElectronVersion = getElectronVersion;
-exports.getElectronVersionFromInstalled = getElectronVersionFromInstalled;
-exports.computeElectronVersion = computeElectronVersion;
+Object.defineProperty(exports, '__esModule', {
+  value: true,
+})
+exports.getElectronVersion = getElectronVersion
+exports.getElectronVersionFromInstalled = getElectronVersionFromInstalled
+exports.computeElectronVersion = computeElectronVersion
 
 function _builderUtil() {
-  const data = require("builder-util");
+  const data = require('builder-util')
 
-  _builderUtil = function () {
-    return data;
-  };
+  _builderUtil = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
 function _nodeHttpExecutor() {
-  const data = require("builder-util/out/nodeHttpExecutor");
+  const data = require('builder-util/out/nodeHttpExecutor')
 
-  _nodeHttpExecutor = function () {
-    return data;
-  };
+  _nodeHttpExecutor = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
 function _fsExtra() {
-  const data = require("fs-extra");
+  const data = require('fs-extra')
 
-  _fsExtra = function () {
-    return data;
-  };
+  _fsExtra = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
 function _lazyVal() {
-  const data = require("lazy-val");
+  const data = require('lazy-val')
 
-  _lazyVal = function () {
-    return data;
-  };
+  _lazyVal = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
-var path = _interopRequireWildcard(require("path"));
+var path = _interopRequireWildcard(require('path'))
 
 function _readConfigFile() {
-  const data = require("read-config-file");
+  const data = require('read-config-file')
 
-  _readConfigFile = function () {
-    return data;
-  };
+  _readConfigFile = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
 function semver() {
-  const data = _interopRequireWildcard(require("semver"));
+  const data = _interopRequireWildcard(require('semver'))
 
-  semver = function () {
-    return data;
-  };
+  semver = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
 function _config() {
-  const data = require("../util/config");
+  const data = require('../util/config')
 
-  _config = function () {
-    return data;
-  };
+  _config = function() {
+    return data
+  }
 
-  return data;
+  return data
 }
 
-function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+function _getRequireWildcardCache() {
+  if (typeof WeakMap !== 'function') return null
+  var cache = new WeakMap()
+  _getRequireWildcardCache = function() {
+    return cache
+  }
+  return cache
+}
 
-const electronPackages = ["electron", "electron-prebuilt", "electron-prebuilt-compile"];
+function _interopRequireWildcard(obj) {
+  if (obj && obj.__esModule) {
+    return obj
+  }
+  var cache = _getRequireWildcardCache()
+  if (cache && cache.has(obj)) {
+    return cache.get(obj)
+  }
+  var newObj = {}
+  if (obj != null) {
+    var hasPropertyDescriptor =
+      Object.defineProperty && Object.getOwnPropertyDescriptor
+    for (var key in obj) {
+      if (Object.prototype.hasOwnProperty.call(obj, key)) {
+        var desc = hasPropertyDescriptor
+          ? Object.getOwnPropertyDescriptor(obj, key)
+          : null
+        if (desc && (desc.get || desc.set)) {
+          Object.defineProperty(newObj, key, desc)
+        } else {
+          newObj[key] = obj[key]
+        }
+      }
+    }
+  }
+  newObj.default = obj
+  if (cache) {
+    cache.set(obj, newObj)
+  }
+  return newObj
+}
 
-async function getElectronVersion(projectDir, config, projectMetadata = new (_lazyVal().Lazy)(() => (0, _readConfigFile().orNullIfFileNotExist)((0, _fsExtra().readJson)(path.join(projectDir, "package.json"))))) {
+const electronPackages = [
+  'electron',
+  'electron-prebuilt',
+  'electron-prebuilt-compile',
+]
+
+async function getElectronVersion(
+  projectDir,
+  config,
+  projectMetadata = new (_lazyVal().Lazy)(() =>
+    (0, _readConfigFile().orNullIfFileNotExist)(
+      (0, _fsExtra().readJson)(path.join(projectDir, 'package.json')),
+    ),
+  ),
+) {
   if (config == null) {
-    config = await (0, _config().getConfig)(projectDir, null, null);
+    config = await (0, _config().getConfig)(projectDir, null, null)
   }
 
   if (config.electronVersion != null) {
-    return config.electronVersion;
+    return config.electronVersion
   }
 
-  return await computeElectronVersion(projectDir, projectMetadata);
+  return await computeElectronVersion(projectDir, projectMetadata)
 }
 
 async function getElectronVersionFromInstalled(projectDir) {
   for (const name of electronPackages) {
     try {
-      return (await (0, _fsExtra().readJson)(path.join(projectDir, "node_modules", name, "package.json"))).version;
+      return (
+        await (0, _fsExtra().readJson)(
+          path.join(projectDir, 'node_modules', name, 'package.json'),
+        )
+      ).version
     } catch (e) {
-      if (e.code !== "ENOENT") {
-        _builderUtil().log.warn({
-          name,
-          error: e
-        }, `cannot read electron version package.json`);
+      if (e.code !== 'ENOENT') {
+        _builderUtil().log.warn(
+          {
+            name,
+            error: e,
+          },
+          `cannot read electron version package.json`,
+        )
       }
     }
   }
 
-  return null;
+  return null
 }
 /** @internal */
 
-
 async function computeElectronVersion(projectDir, projectMetadata) {
-  const result = await getElectronVersionFromInstalled(projectDir);
+  const result = await getElectronVersionFromInstalled(projectDir)
 
   if (result != null) {
-    return result;
+    return result
   }
 
-  const electronVersionFromMetadata = findFromPackageMetadata((await projectMetadata.value));
+  const electronVersionFromMetadata = findFromPackageMetadata(
+    await projectMetadata.value,
+  )
 
-  if (electronVersionFromMetadata === "latest") {
-    _builderUtil().log.warn("Electron version is set to \"latest\", but it is recommended to set it to some more restricted version range.");
+  if (electronVersionFromMetadata === 'latest') {
+    _builderUtil().log.warn(
+      'Electron version is set to "latest", but it is recommended to set it to some more restricted version range.',
+    )
 
     try {
-      const releaseInfo = JSON.parse((await _nodeHttpExecutor().httpExecutor.request({
-        hostname: "github.com",
-        path: "/electron/electron/releases/latest",
-        headers: {
-          accept: "application/json"
-        }
-      })));
-      return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
+      const releaseInfo = JSON.parse(
+        await _nodeHttpExecutor().httpExecutor.request({
+          hostname: 'github.com',
+          path: '/electron/electron/releases/latest',
+          headers: {
+            accept: 'application/json',
+          },
+        }),
+      )
+      return releaseInfo.tag_name.startsWith('v')
+        ? releaseInfo.tag_name.substring(1)
+        : releaseInfo.tag_name
     } catch (e) {
-      _builderUtil().log.warn(e);
+      _builderUtil().log.warn(e)
     }
 
-    throw new (_builderUtil().InvalidConfigurationError)(`Cannot find electron dependency to get electron version in the '${path.join(projectDir, "package.json")}'`);
+    throw new (_builderUtil().InvalidConfigurationError)(
+      `Cannot find electron dependency to get electron version in the '${path.join(
+        projectDir,
+        'package.json',
+      )}'`,
+    )
   }
 
-  if (electronVersionFromMetadata == null || !/^\d/.test(electronVersionFromMetadata)) {
-    const versionMessage = electronVersionFromMetadata == null ? "" : ` and version ("${electronVersionFromMetadata}") is not fixed in project`;
-    throw new (_builderUtil().InvalidConfigurationError)(`Cannot compute electron version from installed node modules - none of the possible electron modules are installed${versionMessage}.\nSee https://github.com/electron-userland/electron-builder/issues/3984#issuecomment-504968246`);
+  if (
+    electronVersionFromMetadata == null ||
+    !/^\d/.test(electronVersionFromMetadata)
+  ) {
+    const versionMessage =
+      electronVersionFromMetadata == null
+        ? ''
+        : ` and version ("${electronVersionFromMetadata}") is not fixed in project`
+    throw new (_builderUtil().InvalidConfigurationError)(
+      `Cannot compute electron version from installed node modules - none of the possible electron modules are installed${versionMessage}.\nSee https://github.com/electron-userland/electron-builder/issues/3984#issuecomment-504968246`,
+    )
   }
 
-  return semver().coerce(electronVersionFromMetadata).toString();
+  return String(electronVersionFromMetadata)
+  // This removes -beta.3
+  // return semver()
+  //   .coerce(electronVersionFromMetadata)
+  //   .toString()
 }
 
 function findFromPackageMetadata(packageData) {
   for (const name of electronPackages) {
-    const devDependencies = packageData.devDependencies;
-    let dep = devDependencies == null ? null : devDependencies[name];
+    const devDependencies = packageData.devDependencies
+    let dep = devDependencies == null ? null : devDependencies[name]
 
     if (dep == null) {
-      const dependencies = packageData.dependencies;
-      dep = dependencies == null ? null : dependencies[name];
+      const dependencies = packageData.dependencies
+      dep = dependencies == null ? null : dependencies[name]
     }
 
     if (dep != null) {
-      return dep;
+      return dep
     }
   }
 
-  return null;
+  return null
 } 
 // __ts-babel@6.0.4
 //# sourceMappingURL=electronVersion.js.map
\ No newline at end of file
diff --git a/node_modules/app-builder-lib/out/targets/ArchiveTarget.js b/node_modules/app-builder-lib/out/targets/ArchiveTarget.js
index fcd3fcc..9c26d96 100755
--- a/node_modules/app-builder-lib/out/targets/ArchiveTarget.js
+++ b/node_modules/app-builder-lib/out/targets/ArchiveTarget.js
@@ -120,7 +120,8 @@ class ArchiveTarget extends _core().Target {
       await (0, _archive().archive)(format, artifactPath, dirToArchive, archiveOptions);
 
       if (this.isWriteUpdateInfo && format === "zip") {
-        updateInfo = await (0, _differentialUpdateInfoBuilder().appendBlockmap)(artifactPath);
+         // This causes ZIP to become invalid
+        // updateInfo = await (0, _differentialUpdateInfoBuilder().appendBlockmap)(artifactPath);
       }
     }
 
